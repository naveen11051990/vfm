---
- name: Staged PAN-OS software upgrade
  hosts: "{{ hosts | default('PA-FW') }}"
  connection: local

  vars:
    device:
      ip_address: "{{ ip_address }}"
      username: "{{ username }}"
      password: "{{ password }}"

    # Target PAN-OS version to reach, e.g. "11.1.10-h1"
    target_version: "{{ target_os_version }}"

    # Reboot after each install step (recommended)
    reboot_between_steps: true

    # Suppress noisy logs during long polling
    quiet_polling: true

    # Tuning for downloads and reboots
    download_retries: 3
    download_delay: 60
    restart_down_timeout: 300
    restart_up_timeout: 900
    ready_retries: 60
    ready_delay: 15

  collections:
    - paloaltonetworks.panos
    - community.general

  tasks:
    - name: Ensure target_version is provided
      assert:
        that:
          - target_version is defined
          - target_version | length > 0
        fail_msg: "You must provide -e target_version=<panos_version> to run a staged upgrade."

    - name: Gather system info (to detect current PAN-OS)
      paloaltonetworks.panos.panos_op:
        provider: "{{ device }}"
        cmd: "show system info"
      register: system_info

    - name: Parse current PAN-OS version (list)
      set_fact:
        current_version_raw: "{{ system_info.stdout_xml | regex_findall('<sw-version>([^<]+)</sw-version>') }}"

    - name: Reduce current version to scalar
      set_fact:
        current_version: "{{ (current_version_raw[0] if (current_version_raw | length) > 0 else 'unknown') }}"

    - name: Derive series identifiers (major.minor)
      set_fact:
        current_series: "{{ (current_version | regex_search('^(\\d+\\.\\d+)')) | default('') }}"
        target_series: "{{ (target_version  | regex_search('^(\\d+\\.\\d+)')) | default('') }}"
    - name: Refresh software index from update server
      paloaltonetworks.panos.panos_op:
        provider: "{{ device }}"
        cmd: "request system software check"
      register: sw_check

    - name: Get available software versions info
      paloaltonetworks.panos.panos_op:
        provider: "{{ device }}"
        cmd: "request system software info"
      register: sw_info

    - name: Extract available versions from software info
      set_fact:
        available_versions_raw: "{{ sw_info.stdout_xml | regex_findall('<version>([^<]+)</version>') | list }}"

    - name: Sort and normalize available versions
      set_fact:
        available_versions: "{{ available_versions_raw | unique | community.general.version_sort }}"

    - name: Derive available series from versions
      set_fact:
        available_series: "{{ available_versions | map('regex_search','^(\\d+\\.\\d+)') | list | select('string') | unique | community.general.version_sort }}"

    - name: Validate target_version is in available list
      assert:
        that:
          - target_version in available_versions
        fail_msg: "Target version {{ target_version }} not found in 'request system software info'. Ensure it is visible or run a software check."

    - name: Initialize planned upgrade list
      set_fact:
        planned_versions: []

    - name: Capture ordered series list
      set_fact:
        series_ordered: "{{ available_series }}"

    - name: Compute series indices
      set_fact:
        current_idx: "{{ ((series_ordered.index(current_series)) if (current_series in series_ordered) else -1) | int }}"
        target_idx: "{{ ((series_ordered.index(target_series)) if (target_series in series_ordered) else -1) | int }}"

    - name: Compute intermediate series slice
      set_fact:
        intermediate_series: "{{ series_ordered[(current_idx | int)+1:(target_idx | int)] if (current_idx is defined and target_idx is defined and (current_idx | int) >= 0 and (target_idx | int) >= 0 and (target_idx | int) > (current_idx | int)) else [] }}"

    - name: Plan step within current series when target is later series
      vars:
        cs_esc: "{{ current_series | replace('.', '\\.') }}"
        cs_versions: "{{ available_versions | select('search', '^' ~ cs_esc ~ '\\.') | list | community.general.version_sort }}"
        cs_bases: "{{ cs_versions | select('search', '^' ~ cs_esc ~ '\\.\\d+$') | list | community.general.version_sort }}"
        cs_base_latest: "{{ (cs_bases | last) | default('') }}"
        cs_hotfix_nums: "{{ cs_versions | select('search', '^' ~ (cs_base_latest | replace('.', '\\.')) ~ '-h\\d+$') | map('regex_search','-h(\\d+)$','\\1') | map('int') | list }}"
        cs_hotfix_max: "{{ ((cs_hotfix_nums | max) | default(0, true)) | int }}"
        cs_latest: "{{ ((cs_hotfix_max | int) > 0) | ternary(cs_base_latest ~ '-h' ~ (cs_hotfix_max | string), cs_base_latest) }}"
        current_is_base: "{{ current_version is match('^' ~ cs_esc ~ '\\.0$') }}"
      set_fact:
        planned_versions: "{{ planned_versions + ([cs_latest] if (target_series != current_series and current_is_base and cs_latest|length > 0 and cs_latest != current_version) else []) }}"
      when:
        - current_series | length > 0
        - target_series | length > 0

    - name: Plan intermediate series (base then latest)
      vars:
        series: "{{ item }}"
        s_esc: "{{ series | replace('.', '\\.') }}"
        s_versions: "{{ available_versions | select('search', '^' ~ s_esc ~ '\\.') | list | community.general.version_sort }}"
        s_base_exact: "{{ s_versions | select('search', '^' ~ s_esc ~ '\\.0($|-)') | list | first | default('') }}"
        s_base: "{{ s_base_exact if s_base_exact|length > 0 else (s_versions | first | default('')) }}"
        s_bases: "{{ s_versions | select('search', '^' ~ s_esc ~ '\\.\\d+$') | list | community.general.version_sort }}"
        s_base_latest: "{{ (s_bases | last) | default('') }}"
        s_hotfix_nums: "{{ s_versions | select('search', '^' ~ (s_base_latest | replace('.', '\\.')) ~ '-h\\d+$') | map('regex_search','-h(\\d+)$','\\1') | map('int') | list }}"
        s_hotfix_max: "{{ ((s_hotfix_nums | max) | default(0, true)) | int }}"
        s_latest: "{{ ((s_hotfix_max | int) > 0) | ternary(s_base_latest ~ '-h' ~ (s_hotfix_max | string), s_base_latest) }}"
      set_fact:
        planned_versions: "{{ planned_versions + ([s_base] if s_base|length > 0 else []) + ([s_latest] if s_latest|length > 0 and s_latest != s_base else []) }}"
      when:
        - intermediate_series | length > 0
      loop: "{{ intermediate_series }}"

    - name: Plan target series steps (base then target)
      vars:
        ts_esc: "{{ target_series | replace('.', '\\.') }}"
        ts_versions: "{{ available_versions | select('search', '^' ~ ts_esc ~ '\\.') | list | community.general.version_sort }}"
        ts_base: "{{ ts_versions | select('search', '^' ~ ts_esc ~ '\\.0($|-)') | list | first | default((ts_versions | first) | default('')) }}"
      set_fact:
        planned_versions: >-
          {{ planned_versions
             + ((current_series != target_series and ts_base|length > 0 and ts_base != current_version)
                | ternary([ts_base], []))
             + ((target_version is defined and target_version != '' and target_version != ts_base)
                | ternary([target_version], [])) }}
      when:
        - target_series | length > 0

    - name: Handle same-series direct upgrade case
      set_fact:
        planned_versions: "{{ [target_version] if (current_series == target_series and current_version != target_version) else planned_versions }}"

    - name: Show computed staged upgrade path
      debug:
        msg: >-
          Current: {{ current_version }} | Target: {{ target_version }} | Plan: {{ planned_versions | join(' -> ') if planned_versions|length > 0 else 'Already at target' }}

    - name: Short-circuit when already at target version
      meta: end_play
      when: current_version == target_version or planned_versions | length == 0

    - name: Execute staged upgrades with per-step reboot
      ansible.builtin.include_tasks: tasks/upgrade_step.yml
      loop: "{{ planned_versions }}"
      loop_control:
        label: "{{ item }}"
      vars:
        version_item: "{{ item }}"
      when: reboot_between_steps | bool

    - name: Execute staged upgrades with single final reboot (install-only per step)
      ansible.builtin.include_tasks: tasks/upgrade_install_only.yml
      loop: "{{ planned_versions }}"
      loop_control:
        label: "{{ item }}"
      vars:
        version_item: "{{ item }}"
      when: not (reboot_between_steps | bool)

    - name: Restart once after final install
      when: not (reboot_between_steps | bool)
      block:
        - name: Restart device to apply final version
          paloaltonetworks.panos.panos_op:
            provider: "{{ device }}"
            cmd: "request restart system"
          async: 45
          poll: 0

        - name: Wait for device to stop responding (reboot start)
          ansible.builtin.wait_for:
            host: "{{ device.ip_address }}"
            port: 443
            state: stopped
            timeout: "{{ restart_down_timeout }}"
          delegate_to: localhost

        - name: Wait for device to start responding (reboot complete)
          ansible.builtin.wait_for:
            host: "{{ device.ip_address }}"
            port: 443
            state: started
            timeout: "{{ restart_up_timeout }}"
          delegate_to: localhost

        - name: Final readiness check after final reboot
          paloaltonetworks.panos.panos_check:
            provider: "{{ device }}"
          register: ready_result
          until: ready_result is not failed and ready_result.msg == 'Device is ready.'
          retries: "{{ ready_retries }}"
          delay: "{{ ready_delay }}"
          no_log: "{{ quiet_polling }}"

        - name: Fetch system info for final version verification
          paloaltonetworks.panos.panos_op:
            provider: "{{ device }}"
            cmd: "show system info"
          register: final_sysinfo

        - name: Parse installed version list from system info (final)
          set_fact:
            final_installed_list: "{{ final_sysinfo.stdout_xml | regex_findall('<sw-version>([^<]+)</sw-version>') }}"

        - name: Reduce final installed version to scalar
          set_fact:
            final_installed_version: "{{ (final_installed_list[0] if (final_installed_list | length) > 0 else '') }}"

        - name: Assert device is on target version {{ target_version }}
          assert:
            that:
              - final_installed_version == target_version
            fail_msg: "Upgrade failed. Device reports {{ final_installed_version }} but should be {{ target_version }}."
            success_msg: "Successfully upgraded to {{ target_version }}."
    - name: Short-circuit when target is not newer
      meta: end_play
      when:
        - current_version is defined
        - target_version is defined
        - current_version is match('^\\d')
        - target_version is match('^\\d')
        - not (current_version is version(target_version, '<'))
