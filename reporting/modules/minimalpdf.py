"""
A minimal PDF generator that allows for basic text rendering, page management, and metadata
handling. This class supports dynamic margins, text wrapping, and simple table-like structures.
It is designed to create a PDF document with customizable dimensions and margins, and provides
methods to add text, headers, and rows with dynamic column widths. The generated PDF can be
saved to a file or returned as a binary stream. The PDF version is set to 1.4, and the class
does not depend on any external libraries for PDF generation.
"""

import io
from collections import namedtuple

_PageSettings = namedtuple(
    '_PageSettings', ['page_width', 'page_height', 'margin', 'y'])
_FontSettings = namedtuple(
    '_FontSettings', ['font', 'font_size', 'leading', 'char_width', 'font_style'])


class MinimalPDF:
    """
    Define functionality for a minimal PDF generator.
    """

    def __init__(self, filename, page_size=(595, 842), margin=50, font='Helvetica'):
        """
        Initialize the MinimalPDF class.
        """
        self.filename = filename
        page_width, page_height = page_size
        self._page_settings = _PageSettings(
            page_width, page_height, margin, page_height - margin
        )
        font_val = font if font in ['Helvetica', 'Courier'] else 'Helvetica'
        char_width = 6 if font_val == 'Courier' else 7
        self._font_settings = _FontSettings(font_val, 12, 16, char_width, '')
        self.pages = []
        self.current_content = ""
        self.metadata = self.generate_default_metadata()

    def generate_default_metadata(self):
        """
        This method initializes the PDF metadata with default values.
        """

        return {
            "Title": "Untitled PDF",
            "Author": "Generated by MinimalPDF",
            "Producer": "MinimalPDF Python",
            "PageCount": 0,
            "PDFVersion": "1.4",
            "CustomMetadata": "No",
            "Tagged": "No",
            "Encrypted": "No",
        }

    def set_metadata(self, key, value):
        """
        Sets a custom metadata field for the PDF document.
        """

        self.metadata[key] = value

    def get_usable_width(self):
        """
        Calculates the usable width of the PDF page.
        """

        return self._page_settings.page_width - 2 * self._page_settings.margin

    @property
    def margin(self):
        """Get the current margin value."""
        return self._page_settings.margin

    @property
    def y(self):
        """Get the current y position."""
        return self._page_settings.y

    @property
    def leading(self):
        """Get the current leading value."""
        return self._font_settings.leading

    @y.setter
    def y(self, value):
        """Set the current y position."""
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            value
        )

    @margin.setter
    def margin(self, value):
        """Set the current margin value."""
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            value,
            self._page_settings.page_height - value
        )

    def add_page(self):
        """
        Adds a new page to the PDF document.
        """

        if self.current_content:
            self.pages.append(self.current_content)
            self.current_content = ""

        new_y = self._page_settings.page_height - \
            self._page_settings.margin - self._font_settings.leading
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            new_y
        )
        self.draw_page_border()

    def set_font(self, size, font=None):
        """
        Sets the font and size for the PDF document.
        """
        font_val = self._font_settings.font
        if font and font in ['Helvetica', 'Courier']:
            font_val = font
        leading = int(size * 1.3)
        char_width = size * 0.6
        self._font_settings = _FontSettings(
            font_val,
            size,
            leading,
            char_width,
            ''
        )

    def _hex_to_rgb(self, hex_color):
        """
        Convert hex color code to RGB tuple (0-1 range).
        """
        # Remove '#' if present
        hex_color = hex_color.lstrip('#')

        # Handle short form (e.g., #ABC -> AABBCC)
        if len(hex_color) == 3:
            hex_color = ''.join([c * 2 for c in hex_color])

        # Convert to RGB values in 0-1 range
        try:
            r = int(hex_color[0:2], 16) / 255.0
            g = int(hex_color[2:4], 16) / 255.0
            b = int(hex_color[4:6], 16) / 255.0
            return (r, g, b)
        except (ValueError, IndexError):
            # Default to white on error
            return (1.0, 1.0, 1.0)

    def _set_fill_color(self, color):
        """
        Set the fill color for subsequent drawing operations.
        """
        if isinstance(color, str):
            # Handle hex color
            r, g, b = self._hex_to_rgb(color)
        elif isinstance(color, (tuple, list)) and len(color) == 3:
            # Handle RGB tuple (0-255 range)
            r, g, b = [max(0.0, min(c/255.0, 1.0)) for c in color]
        else:
            # Default to white
            r, g, b = 1.0, 1.0, 1.0

        return f"{r:.3f} {g:.3f} {b:.3f} rg "

    def text(self, x, y, txt, style=None):
        """
        Draw text at position (x, y).
        """
        # Default style if none provided
        if style is None:
            style = {}

        # Extract style properties
        bold = style.get('bold', False)
        italic = style.get('italic', False)
        fill_color = style.get('fill_color', None)

        # Determine font reference directly
        font_name = self._font_settings.font
        if bold and italic:
            font_name += '-BoldItalic'
        elif bold:
            font_name += '-Bold'
        elif italic:
            font_name += '-Italic'

        # Font map must match the order of font definitions in output()
        font_map = {
            'Helvetica': 'F1', 'Courier': 'F2', 'Helvetica-Bold': 'F3',
            'Helvetica-Italic': 'F4', 'Helvetica-BoldItalic': 'F5',
            'Courier-Bold': 'F6', 'Courier-Italic': 'F7', 'Courier-BoldItalic': 'F8'
        }
        font_ref = font_map.get(font_name, 'F1')

        # Add fill color if specified
        if fill_color is not None:
            self.current_content += "q\n"
            self.current_content += self._set_fill_color(fill_color)
            # Calculate text width for background rectangle
            text_width = len(txt) * self._font_settings.char_width * \
                (self._font_settings.font_size / 12)
            self.current_content += (
                f"{x-1} {y-self._font_settings.font_size+1} {text_width+2} "
                f"{self._font_settings.leading+2} re f\n"
            )
            self.current_content += "Q\n"

        # Escape special characters
        txt = self._escape(txt)

        # Calculate max characters and clip text
        adjusted_char_width = self._font_settings.char_width * \
            (self._font_settings.font_size / 12)
        max_chars = int((self._page_settings.page_width - x -
                        self._page_settings.margin) / adjusted_char_width)
        if len(txt) > max_chars:
            txt = txt[:max_chars] + "â€¦"

        # Write PDF text command directly
        self.current_content += (
            f"BT /{font_ref} {self._font_settings.font_size} Tf "
            f"{x} {y} Td ({txt}) Tj ET\n"
        )

    def wrap_text(self, txt, max_width):
        """
        Wraps text to fit within a specified width, breaking it
            into lines based on word boundaries.
        """

        # Use font-size adjusted character width for accurate wrapping
        adjusted_char_width = (
            self._font_settings.char_width *
            (self._font_settings.font_size / 12)
        )
        max_chars = max(int(max_width // adjusted_char_width), 1)
        # 200 // 7 => 28 characters max per line. If division results in less than 1, set to 1.

        words = txt.split()
        lines = []
        current = ""
        for word in words:
            if len(current) + len(word) + 1 > max_chars:
                # If adding the next word + space exceeds the max width, save the current line
                # and start a new line with the current word
                if current:
                    lines.append(current)
                current = word
            else:
                if current:
                    # If current line is not empty, add the word with a space
                    current += " " + word
                else:
                    # If current line is empty, just set it to the word
                    current = word
        if current:
            # If there's any remaining text in current, add it as the last line
            lines.append(current)
        return lines

    def wrap_preserve_whitespace(self, line, max_chars=None):
        """
        Wrap text by character count while preserving whitespace and indentation.
        Ideal for code blocks or preformatted text where whitespace matters.
        """
        if max_chars is None:
            # Use font-size adjusted character width for accurate wrapping
            adjusted_char_width = (
                self._font_settings.char_width *
                (self._font_settings.font_size / 12)
            )
            max_chars = max(
                int(self.get_usable_width() // adjusted_char_width), 1)
        result = []
        for i in range(0, len(line), max_chars):
            result.append(line[i:i+max_chars])
        return result

    def draw_separator(self, positions=None):
        """
        Draw a horizontal separator line at the current y position.
        """
        if positions is None:
            # Default: full width separator within margins
            positions = [(self._page_settings.margin,
                          self._page_settings.page_width - self._page_settings.margin)]

        for x_start, x_end in positions:
            self.line(x_start, self._page_settings.y,
                      x_end, self._page_settings.y)
        new_y = self._page_settings.y - self._font_settings.leading
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            new_y
        )

    def draw_row(self, row_data, columns, style=None):
        """
        Draw a row of text in a table-like structure with specified columns.
        """
        if style is None:
            style = {}
        bold = style.get('bold', False)
        italic = style.get('italic', False)
        fill_color = style.get('fill_color', None)
        self._draw_row(row_data, columns, {
                       'bold': bold, 'italic': italic, 'fill_color': fill_color})

    def _draw_row(self, row_data, columns, style):
        """Main row drawing logic - coordinates the process."""
        row_layout = self._prepare_row_layout(row_data, columns)
        self._ensure_page_space(row_layout['row_height'])
        if style.get('fill_color') is not None:
            self._draw_row_background(
                columns, row_layout['row_height'], style['fill_color'])
        self._render_row_content(row_layout, columns, style.get(
            'bold', False), style.get('italic', False))
        self._update_page_position(row_layout['row_height'])

    def _prepare_row_layout(self, row_data, columns):
        """Prepare row layout data including wrapped text and dimensions."""
        cell_padding = 5
        line_height = self._font_settings.leading * 1.2
        wrapped_columns = [
            self.wrap_text(str(data), max(10, col_width - (2 * cell_padding)))
            for data, (_, col_width) in zip(row_data, columns)
        ]
        max_lines = max(len(lines) for lines in wrapped_columns)
        row_height = max_lines * line_height
        return {
            'wrapped_columns': wrapped_columns,
            'max_lines': max_lines,
            'line_height': line_height,
            'row_height': row_height,
            'cell_padding': cell_padding
        }

    def _ensure_page_space(self, row_height):
        """Ensure there's enough space on the page for the row."""
        if self._page_settings.y - row_height < self._page_settings.margin:
            self.add_page()

    def _render_row_content(self, row_layout, columns, bold, italic):
        """Render the actual text content of the row."""
        for line_num in range(row_layout['max_lines']):
            for col_idx, (col_x, _) in enumerate(columns):
                cell_style = self._get_cell_style(bold, italic, col_idx)
                if line_num < len(row_layout['wrapped_columns'][col_idx]):
                    line = row_layout['wrapped_columns'][col_idx][line_num]
                    y_pos = self._page_settings.y - \
                        (line_num * row_layout['line_height'])
                    self.text(
                        col_x + row_layout['cell_padding'], y_pos, line, cell_style)

    def _get_cell_style(self, bold, italic, col_idx):
        """Get the style for a specific cell based on column index."""
        cell_bold = bold[col_idx] if isinstance(
            bold, (list, tuple)) and col_idx < len(bold) else bold
        cell_italic = italic[col_idx] if isinstance(
            italic, (list, tuple)) and col_idx < len(italic) else italic
        return {'bold': cell_bold, 'italic': cell_italic}

    def _update_page_position(self, row_height):
        """Update the page position after drawing the row."""
        line_height = self._font_settings.leading * 1.2
        new_y = self._page_settings.y - row_height - (line_height * 0.5)
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            new_y
        )

    def _draw_row_background(self, columns, row_height, fill_color):
        self.current_content += "q\n"
        self.current_content += self._set_fill_color(fill_color)
        last_col_x, last_col_width = columns[-1] if columns else (0, 0)
        last_col_right = last_col_x + last_col_width
        row_width = (last_col_right - self._page_settings.margin) + 4
        max_width = (
            self._page_settings.page_width - (2 * self._page_settings.margin)
        )
        row_width = min(row_width, max_width)
        self.current_content += (
            f"{self._page_settings.margin} {self._page_settings.y - row_height} "
            f"{row_width} {row_height} re f\n"
        )
        self.current_content += "Q\n"

    def cell(self, w, h, txt, fill_color=None):
        """
        Draw a cell with specified width and height, wrapping text to fit within the cell.
        """
        # Add padding to the left margin so that text does not touch the left border
        left_padding = 10

        # Calculate the usable width for text within the cell
        # w is the width of the cell, margin is the left margin, and
        # left_padding is added to ensure text does not touch the border
        usable_width = w - self._page_settings.margin - left_padding
        # Wrap the text to fit within the usable width
        wrapped_text = self.wrap_text(txt, usable_width)

        # Draw background if fill_color is specified
        if fill_color is not None:
            # Save current graphics state
            self.current_content += "q\n"
            # Set fill color
            self.current_content += self._set_fill_color(fill_color)
            # Draw background rectangle for the entire cell
            self.current_content += (
                f"{self._page_settings.margin} {self._page_settings.y - h} {w} {h} re f\n"
            )
            # Restore graphics state
            self.current_content += "Q\n"

        # Render each line of wrapped text within the cell
        for line in wrapped_text:
            # Adjust text position with padding and move y down to the next line
            self.text(self._page_settings.margin +
                      left_padding, self._page_settings.y, line)
            new_y = self._page_settings.y - self._font_settings.leading
            self._page_settings = _PageSettings(
                self._page_settings.page_width,
                self._page_settings.page_height,
                self._page_settings.margin,
                new_y
            )

        # NOTE: This step of calculating remaining height needs to be removed
        # as there is no point in calculating remaining height after all the
        # lines are written to the cell.
        # Additionally, this step causes layout issues rather than fixing them
        # when using in multi-cell scenarios.

        # TASK: Remove this step and ensure feature works as expected.
        remaining_height = h - (len(wrapped_text) *
                                self._font_settings.leading)
        new_y = self._page_settings.y - remaining_height
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            new_y
        )

        # NOTE: This step is pointless in current implementation as it is
        # called after all the lines are written to the cell. It needs to be
        # implemented in the for loop above where line is written to the cell
        # using text method.

        # TASK: Move this step to the start of for loop.
        if self._page_settings.y < self._page_settings.margin:
            self.add_page()

    def add_header(self, header_text, font_size=18, bold=False, italic=False):
        """
        Add a header to the current page with a centered title and a separator line.
        """
        # Store the current font size to restore later as it will be changed for the header
        old_font_size = self._font_settings.font_size
        # Font size for the header set to 16 points
        self.set_font(font_size)

        # Render the header text centered within the usable width
        usable_width = self.get_usable_width()
        # Calculate the x position to center the header text
        header_x = self._page_settings.margin + \
            (usable_width - len(header_text) * self._font_settings.char_width) // 2
        # Calculate the y position for the header text
        header_y = self._page_settings.page_height - \
            self._page_settings.margin - self._font_settings.leading
        # Add the header text to the current content
        self.text(header_x, header_y, header_text,
                  {'bold': bold, 'italic': italic})

        # Set the y position for the separator line below the header, x start and end positions
        separator_y = header_y - self._font_settings.leading
        separator_start_x = self._page_settings.margin
        separator_end_x = self._page_settings.page_width - self._page_settings.margin

        # Use pdf commands to draw the separator line below the header
        self.current_content += (
            f"{separator_start_x} {separator_y} m {separator_end_x} {separator_y} l S\n"
        )

        # Set y position for the next content below the separator
        self._page_settings = _PageSettings(
            self._page_settings.page_width,
            self._page_settings.page_height,
            self._page_settings.margin,
            separator_y - self._font_settings.leading
        )
        # Restore the original font size
        self.set_font(old_font_size)

        # Add a new page if the vertical position exceeds the margin
        if self._page_settings.y < self._page_settings.margin:
            self.add_page()

    def draw_page_border(self):
        """
        Draw a rectangle border around the page using pdf commands, respecting the margins.
        """
        border_start_x = self._page_settings.margin
        border_start_y = self._page_settings.margin
        border_end_x = self._page_settings.page_width - self._page_settings.margin
        border_end_y = self._page_settings.page_height - self._page_settings.margin

        # Draw the rectangle border
        self.current_content += (
            f"{border_start_x} {border_start_y} m "
            f"{border_end_x} {border_start_y} l "
            f"{border_end_x} {border_end_y} l "
            f"{border_start_x} {border_end_y} l "
            f"h S\n"
        )

    def output(self):
        """
        Generate the PDF content as a binary stream.
        """
        if self.current_content:
            self.pages.append(self.current_content)
        return self._generate_pdf()

    def _generate_pdf(self):
        pdf = io.BytesIO()
        pdf.write(b"%PDF-1.4\n")
        xref = [0]
        obj_count = 1
        info_obj = obj_count
        xref.append(pdf.tell())
        pdf.write(self._info_dict(info_obj).encode())
        obj_count += 1
        font_objs = self._write_fonts(pdf, xref, obj_count)
        obj_count += len(font_objs)
        content_objs, obj_count = self._write_content_streams(
            pdf, xref, obj_count)
        page_objs, obj_count = self._write_page_objects(
            pdf, xref, obj_count, {'fonts': font_objs, 'contents': content_objs})
        pages_obj, obj_count = self._write_pages_root(
            pdf, xref, obj_count, page_objs)
        catalog_obj, obj_count = self._write_catalog(
            pdf, xref, obj_count, pages_obj)
        xref_start = pdf.tell()
        self._write_xref_table(pdf, xref, obj_count, xref_start)
        self._write_trailer(
            pdf, obj_count, {'catalog': catalog_obj, 'info': info_obj}, xref_start)
        pdf.seek(0)
        return pdf

    def _info_dict(self, info_obj):
        return (f"{info_obj} 0 obj\n"
                f"<< /Title ({self.metadata['Title']})\n"
                f"/Author ({self.metadata['Author']})\n"
                f"/Producer ({self.metadata['Producer']})\n"
                f">>\nendobj\n")

    def _write_fonts(self, pdf, xref, obj_count):
        font_defs = [
            ("Helvetica",), ("Courier",), ("Helvetica-Bold",), ("Helvetica-Italic",),
            ("Helvetica-BoldItalic",), ("Courier-Bold",
                                        ), ("Courier-Italic",), ("Courier-BoldItalic",)
        ]
        font_objs = []
        for font in font_defs:
            xref.append(pdf.tell())
            font_obj = obj_count
            font_name = font[0]
            font_def = (
                f"{font_obj} 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /"
                f"{font_name} >>\nendobj\n"
            )
            pdf.write(font_def.encode())
            font_objs.append(font_obj)
            obj_count += 1
        return font_objs

    def _write_content_streams(self, pdf, xref, obj_count):
        content_objs = []
        for content in self.pages:
            xref.append(pdf.tell())
            content_obj = obj_count
            stream_bytes = content.encode()
            stream = (
                f"{content_obj} 0 obj\n<< /Length {len(stream_bytes)} >>\nstream\n"
            ).encode() + stream_bytes + b"\nendstream\nendobj\n"
            pdf.write(stream)
            content_objs.append(content_obj)
            obj_count += 1
        return content_objs, obj_count

    def _write_page_objects(self, pdf, xref, obj_count, objects):
        page_objs = []
        font_objs = objects['fonts']
        content_objs = objects['contents']
        for content_obj in content_objs:
            xref.append(pdf.tell())
            page_obj = obj_count

            # Build font resources dictionary
            font_resources = (
                f"/F1 {font_objs[0]} 0 R /F2 {font_objs[1]} 0 R /F3 {font_objs[2]} 0 R "
                f"/F4 {font_objs[3]} 0 R /F5 {font_objs[4]} 0 R /F6 {font_objs[5]} 0 R "
                f"/F7 {font_objs[6]} 0 R /F8 {font_objs[7]} 0 R"
            )

            # Build media box
            media_box = f"[0 0 {self._page_settings.page_width} {self._page_settings.page_height}]"

            page = (
                f"{page_obj} 0 obj\n"
                f"<< /Type /Page /Parent {obj_count + 1} 0 R /MediaBox {media_box} "
                f"/Contents {content_obj} 0 R /Resources << /Font << {font_resources} >> >> >>\n"
                f"endobj\n"
            )
            pdf.write(page.encode())
            page_objs.append(page_obj)
            obj_count += 1
        return page_objs, obj_count

    def _write_pages_root(self, pdf, xref, obj_count, page_objs):
        xref.append(pdf.tell())
        pages_obj = obj_count
        kids = " ".join([f"{p} 0 R" for p in page_objs])
        pages = (
            f"{pages_obj} 0 obj\n"
            f"<< /Type /Pages /Kids [{kids}] /Count {len(page_objs)} >>\n"
            f"endobj\n"
        )
        pdf.write(pages.encode())
        obj_count += 1
        return pages_obj, obj_count

    def _write_catalog(self, pdf, xref, obj_count, pages_obj):
        xref.append(pdf.tell())
        catalog_obj = obj_count
        catalog = (
            f"{catalog_obj} 0 obj\n"
            f"<< /Type /Catalog /Pages {pages_obj} 0 R >>\n"
            f"endobj\n"
        )
        pdf.write(catalog.encode())
        obj_count += 1
        return catalog_obj, obj_count

    def _write_xref_table(self, pdf, xref, obj_count, xref_start):
        pdf.write(f"xref\n0 {obj_count}\n".encode())
        for i in range(obj_count):
            if i < len(xref):
                pdf.write(f"{xref[i]:010} 00000 n \n".encode())
            else:
                pdf.write(f"{xref_start:010} 00000 f \n".encode())

    def _write_trailer(self, pdf, obj_count, objects, xref_start):
        catalog_obj = objects['catalog']
        info_obj = objects['info']
        pdf.write(
            (
                f"trailer\n<< /Size {obj_count} /Root {catalog_obj} 0 R /Info {info_obj} 0 R >>\n"
                f"startxref\n{xref_start}\n%%EOF\n"
            ).encode()
        )

    def _escape(self, txt):
        """
        Escape special characters in the text to ensure it is correctly
            formatted for PDF output.
        """
        return txt.replace("\\", "\\\\").replace("(", "\\(").replace(")", "\\)")

    def line(self, x1, y1, x2, y2):
        """
        Draw a line from (x1, y1) to (x2, y2).
        """
        self.current_content += f"{x1} {y1} m {x2} {y2} l S\n"
