---
- name: PAN-OS HA Content and Software Upgrade with Config Backup
  hosts: "{{ hosts | default('PA-HA') }}"
  connection: local
  gather_facts: false

  vars:
    device:
      ip_address: "{{ ip_address }}"
      username: "{{ username }}"
      password: "{{ password }}"

    backup_directory: "{{ lookup('env', 'PANOS_BACKUP_DIR') | default('/runner/backups', true) }}"
    backup_filename: "{{ backup_directory }}/{{ inventory_hostname | default('pa-fw') }}-running-config.xml"

    reboot_between_steps: true
    quiet_polling: true

  collections:
    - paloaltonetworks.panos

  tasks:
    - name: Validate upgrade_path is provided
      ansible.builtin.assert:
        that:
          - upgrade_path is defined
          - upgrade_path | length > 0
        fail_msg: 'You must provide -e upgrade_path=''["10.2.3","10.2.4"]'''
      run_once: true

    - name: Gather HA and system facts
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["system", "ha"]
      register: ha_facts

    - name: Gather full HA configuration (running config)
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["config"]
      register: ha_cfg

    - name: Record HA snapshot for {{ inventory_hostname }}
      ansible.builtin.set_fact:
        ha_runtime:
          inventory_hostname: "{{ inventory_hostname }}"
          hostname: "{{ ha_facts.ansible_facts.ansible_net_hostname }}"
          serial: "{{ ha_facts.ansible_facts.ansible_net_serialnum | default('unknown') }}"
          sw_version: "{{ ha_facts.ansible_facts.ansible_net_version | default('unknown') }}"
          ha_enabled: "{{ (ha_facts.ansible_facts.ansible_net_ha_enabled | default(false)) | bool }}"
          ha_mode: "{{ (ha_facts.ansible_facts.ansible_net_ha_localmode | default('unknown')) | lower }}"
          ha_initial_role: "{{ (ha_facts.ansible_facts.ansible_net_ha_localstate | default('unknown')) | lower }}"
          ha_group_id: "{{ ha_facts.ansible_facts.ansible_net_ha_group_id | default('1') }}"

    - name: Extract HA section from config
      ansible.builtin.set_fact:
        ha_section: "{{ ha_cfg.ansible_facts.ansible_net_config | regex_search('(?s)<high-availability>.*?</high-availability>') | default('') }}"

    - name: Discover HA interface wiring from running config
      ansible.builtin.set_fact:
        ha1_ip_address: >-
          {{ (ha_section
              | regex_findall('<ip-address>([^<]+)</ip-address>')
              | default([''], true))
             | first }}
        ha1_netmask: >-
          {{ (ha_section
              | regex_findall('<netmask>([^<]+)<')
              | default([''], true))
             | first }}
        ha1_port: >-
          {{ (ha_section
              | regex_findall('<port>([^<]+)</port>')
              | default([''], true))
             | first }}
        ha_peer_ip: >-
          {{ (ha_section
              | regex_findall('<peer-ip>([^<]+)</peer-ip>')
              | default([''], true))
             | first }}

    - name: Validate discovered HA wiring
      ansible.builtin.assert:
        that:
          - ha1_ip_address | length > 0
          - ha1_netmask | length > 0
          - ha1_port | length > 0
          - ha_peer_ip | length > 0
        fail_msg: >-
          Failed to auto-discover HA1/HA2/peer wiring from running config.
          Verify high-availability is configured under deviceconfig on each firewall.

    - name: Validate HA1 control channel via Upgrade Assurance
      paloaltonetworks.panos.panos_active_in_ha:
        provider: "{{ device }}"
      register: ha_upgrade_assurance_raw

    - name: Record HA1 pre-check result for {{ inventory_hostname }}
      ansible.builtin.set_fact:
        ha_upgrade_assurance: >-
          {{
            {
              'inventory_hostname': inventory_hostname,
              'is_active': (ha_upgrade_assurance_raw.response.active | default(false)),
              'response_reason': (ha_upgrade_assurance_raw.response.reason | default(''))
            }
          }}

    - name: Enforce HA1 pre-check status across HA pair
      run_once: true
      delegate_to: localhost
      delegate_facts: true
      vars:
        ha1_checks: "{{ ansible_play_hosts_all | map('extract', hostvars, 'ha_upgrade_assurance') | list }}"
      block:
        - name: Assert Upgrade Assurance sees exactly one active node
          ansible.builtin.assert:
            that:
              - ha1_checks | length == 2
              - (ha1_checks | map(attribute='is_active') | select('equalto', true) | list | length) == 1
              - (ha1_checks | map(attribute='is_active') | select('equalto', false) | list | length) == 1
            fail_msg: >-
              HA1 pre-check failed: expected one active and one passive peer but received {{ ha1_checks }}.
        - name: Persist HA1 pre-check snapshot
          ansible.builtin.set_fact:
            ha1_upgrade_assurance_snapshot: "{{ ha1_checks }}"

    - name: Consolidate HA topology view
      run_once: true
      delegate_to: localhost
      delegate_facts: true
      vars:
        ha_view: "{{ ansible_play_hosts_all | map('extract', hostvars, 'ha_runtime') | list }}"
      block:
        - name: Validate HA pair is active/passive and healthy
          ansible.builtin.assert:
            that:
              - ha_view | length == 2
              - (ha_view | map(attribute='ha_enabled') | min)
              - (ha_view | map(attribute='ha_mode') | unique) == ['active-passive']
              - (ha_view | selectattr('ha_initial_role', 'equalto', 'active') | list | length) == 1
              - (ha_view | selectattr('ha_initial_role', 'equalto', 'passive') | list | length) == 1
            fail_msg: "Playbook currently supports exactly two nodes in active/passive HA."
        - name: Persist HA role ownership
          ansible.builtin.set_fact:
            ha_topology: "{{ ha_view }}"
            ha_active_host: "{{ (ha_view | selectattr('ha_initial_role', 'equalto', 'active') | first).inventory_hostname }}"
            ha_passive_host: "{{ (ha_view | selectattr('ha_initial_role', 'equalto', 'passive') | first).inventory_hostname }}"

    - name: Short-circuit when upgrade path does not advance PAN-OS
      run_once: true
      vars:
        ha_topology_view: "{{ hostvars['localhost'].ha_topology | default([]) }}"
      ansible.builtin.assert:
        that:
          - "(upgrade_path | select('version', item.sw_version | default('0.0.0'), '<=') | list | length) == 0"
        fail_msg: >-
          Short-circuiting upgrade: host {{ item.hostname | default(item.inventory_hostname) }} ({{ item.inventory_hostname }})
          already runs PAN-OS {{ item.sw_version | default('unknown') }}, and requested upgrade_path entries
          {{ upgrade_path | select('version', item.sw_version | default('0.0.0'), '<=') | list }} are not higher. Remove or
          replace the lower-or-equal versions before rerunning the playbook.
      loop: "{{ ha_topology_view }}"
      loop_control:
        label: "{{ item.inventory_hostname }}"

    - name: Mark initial HA role flags
      ansible.builtin.set_fact:
        is_initial_active: "{{ ha_runtime.ha_initial_role == 'active' }}"
        is_initial_passive: "{{ ha_runtime.ha_initial_role == 'passive' }}"

    # - name: Include content and antivirus update tasks
    #   ansible.builtin.import_tasks: tasks/content_and_antivirus_update.yml

    - name: Backup running configuration
      paloaltonetworks.panos.panos_export:
        provider: "{{ device }}"
        category: configuration
        filename: "{{ backup_filename }}"
        create_directory: true

    - name: Determine tech-support bundle filename
      ansible.builtin.set_fact:
        tech_support_bundle_path: >-
          {{ backup_directory }}/{{ inventory_hostname | default('pa-fw') }}-tech-support-{{ lookup('pipe', 'date +%Y%m%d%H%M%S') }}.tgz

    - name: Capture tech-support bundle before upgrade
      paloaltonetworks.panos.panos_export:
        provider: "{{ device }}"
        category: tech-support
        filename: "{{ tech_support_bundle_path }}"
        create_directory: true

    - name: Verify HA readiness (includes config-sync) before upgrade
      paloaltonetworks.panos.panos_readiness_checks:
        provider: "{{ device }}"
        checks:
          - ha
        force_fail: true

    - name: Disable config sync (HA module not reliable with existing HA2 wiring)
      paloaltonetworks.panos.panos_type_cmd:
        provider: "{{ device }}"
        cmd: set
        xpath: "/config/devices/entry[@name='localhost.localdomain']/deviceconfig/high-availability/group/configuration-synchronization"
        element: "<enabled>no</enabled>"

    - name: Commit HA change (config sync disabled)
      paloaltonetworks.panos.panos_commit_firewall:
        provider: "{{ device }}"
        description: "Disable HA config sync before OS upgrade"

    - name: Re-collect HA facts after disabling config sync
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["ha"]
      register: ha_post_disable

    - name: Verify HA state after disabling config sync
      ansible.builtin.assert:
        that:
          - ha_post_disable.ansible_facts.ansible_net_ha_enabled | bool
          - (ha_post_disable.ansible_facts.ansible_net_ha_localmode | lower) == 'active-passive'
          - ha_post_disable.ansible_facts.ansible_net_ha_localstate | lower in ['active', 'passive']
        fail_msg: "Unexpected HA state after disabling config sync; check HA configuration on device."

    # - name: Verify antivirus versions match across HA peers
    #   run_once: true
    #   vars:
    #     antivirus_versions: "{{ ansible_play_hosts_all | map('extract', hostvars, 'ha_antivirus_version') | list }}"
    #   ansible.builtin.assert:
    #     that:
    #       - antivirus_versions | reject('equalto', 'unknown') | list | length == antivirus_versions | length
    #       - (antivirus_versions | unique | length) == 1
    #     fail_msg: >-
    #       Antivirus update mismatch detected across HA peers: {{ antivirus_versions }}. Ensure both devices downloaded and
    #       installed the latest antivirus package before proceeding.

    - name: Orchestrate passive-first upgrade sequence (controller-driven)
      run_once: true
      vars:
        passive_host: "{{ hostvars['localhost'].ha_passive_host }}"
        active_host: "{{ hostvars['localhost'].ha_active_host }}"
      block:
        - name: Wait for passive device to be ready (no running commits)
          paloaltonetworks.panos.panos_check:
            provider:
              ip_address: "{{ hostvars[passive_host].ip_address }}"
              username: "{{ hostvars[passive_host].username }}"
              password: "{{ hostvars[passive_host].password }}"
          register: passive_ready_before_upgrade
          until: passive_ready_before_upgrade is not failed and passive_ready_before_upgrade.msg == 'Device is ready.'
          retries: 60
          delay: 10

        # - name: Upgrade passive firewall first
        #   ansible.builtin.include_tasks: tasks/upgrade_step_v2.yml
        #   loop: "{{ upgrade_path }}"
        #   loop_control:
        #     label: "{{ item }}"
        #   vars:
        #     version_item: "{{ item }}"
        #     device:
        #       ip_address: "{{ hostvars[passive_host].ip_address }}"
        #       username: "{{ hostvars[passive_host].username }}"
        #       password: "{{ hostvars[passive_host].password }}"

        - name: Suspend original active to trigger failover
          paloaltonetworks.panos.panos_op:
            provider:
              ip_address: "{{ hostvars[active_host].ip_address }}"
              username: "{{ hostvars[active_host].username }}"
              password: "{{ hostvars[active_host].password }}"
            cmd: "request high-availability state suspend"

        - name: Wait until upgraded passive becomes active and ready
          block:
            - name: Check HA role on upgraded passive
              paloaltonetworks.panos.panos_facts:
                provider:
                  ip_address: "{{ hostvars[passive_host].ip_address }}"
                  username: "{{ hostvars[passive_host].username }}"
                  password: "{{ hostvars[passive_host].password }}"
                gather_subset: ["ha"]
              register: passive_ha_after_failover
              until: (passive_ha_after_failover.ansible_facts.ansible_net_ha_localstate | lower) == 'active'
              retries: 40
              delay: 15

            - name: Wait for upgraded passive (now active) readiness
              paloaltonetworks.panos.panos_check:
                provider:
                  ip_address: "{{ hostvars[passive_host].ip_address }}"
                  username: "{{ hostvars[passive_host].username }}"
                  password: "{{ hostvars[passive_host].password }}"
              register: passive_ready_as_active
              until: passive_ready_as_active is not failed and passive_ready_as_active.msg == 'Device is ready.'
              retries: 60
              delay: 15

        - name: Wait for original active device to be ready (no running commits)
          paloaltonetworks.panos.panos_check:
            provider:
              ip_address: "{{ hostvars[active_host].ip_address }}"
              username: "{{ hostvars[active_host].username }}"
              password: "{{ hostvars[active_host].password }}"
          register: active_ready_before_upgrade
          until: active_ready_before_upgrade is not failed and active_ready_before_upgrade.msg == 'Device is ready.'
          retries: 60
          delay: 10

        # - name: Upgrade originally active firewall
        #   ansible.builtin.include_tasks: tasks/upgrade_step_v2.yml
        #   loop: "{{ upgrade_path }}"
        #   loop_control:
        #     label: "{{ item }}"
        #   vars:
        #     version_item: "{{ item }}"
        #     device:
        #       ip_address: "{{ hostvars[active_host].ip_address }}"
        #       username: "{{ hostvars[active_host].username }}"
        #       password: "{{ hostvars[active_host].password }}"

        - name: Return suspended firewall to functional state
          paloaltonetworks.panos.panos_op:
            provider:
              ip_address: "{{ hostvars[active_host].ip_address }}"
              username: "{{ hostvars[active_host].username }}"
              password: "{{ hostvars[active_host].password }}"
            cmd: "request high-availability state functional"

    - name: Re-enable config sync
      paloaltonetworks.panos.panos_type_cmd:
        provider: "{{ device }}"
        cmd: set
        xpath: "/config/devices/entry[@name='localhost.localdomain']/deviceconfig/high-availability/group/configuration-synchronization"
        element: "<enabled>yes</enabled>"

    - name: Commit HA change (config sync enabled)
      paloaltonetworks.panos.panos_commit_firewall:
        provider: "{{ device }}"
        description: "Re-enable HA config sync after OS upgrade"


    - name: Ensure original active regains active role if needed
      run_once: true
      vars:
        original_active: "{{ hostvars['localhost'].ha_active_host }}"
        original_passive: "{{ hostvars['localhost'].ha_passive_host }}"
      block:
        - name: Check current HA roles after upgrades
          paloaltonetworks.panos.panos_facts:
            provider:
              ip_address: "{{ hostvars[item].ip_address }}"
              username: "{{ hostvars[item].username }}"
              password: "{{ hostvars[item].password }}"
            gather_subset: ["ha"]
          loop: "{{ [original_active, original_passive] }}"
          register: final_ha_view

        - name: Derive current active host after upgrades
          ansible.builtin.set_fact:
            current_active_host: >-
              {{ (final_ha_view.results
                    | selectattr('ansible_facts.ansible_net_ha_localstate', 'defined')
                    | selectattr('ansible_facts.ansible_net_ha_localstate', 'equalto', 'active')
                    | map(attribute='item') | list | first | default('')) }}

        - name: Suspend current active to fail back to original active
          paloaltonetworks.panos.panos_op:
            provider:
              ip_address: "{{ hostvars[current_active_host].ip_address }}"
              username: "{{ hostvars[current_active_host].username }}"
              password: "{{ hostvars[current_active_host].password }}"
            cmd: "request high-availability state suspend"
          when:
            - current_active_host is defined
            - current_active_host | length > 0
            - current_active_host != original_active

        - name: Wait for original active to become active again after failback
          paloaltonetworks.panos.panos_facts:
            provider:
              ip_address: "{{ hostvars[original_active].ip_address }}"
              username: "{{ hostvars[original_active].username }}"
              password: "{{ hostvars[original_active].password }}"
            gather_subset: ["ha"]
          register: final_active_after_failback
          until: (final_active_after_failback.ansible_facts.ansible_net_ha_localstate | lower) == 'active'
          retries: 40
          delay: 30
          when:
            - current_active_host is defined
            - current_active_host | length > 0
            - current_active_host != original_active

        - name: Return suspended firewall to functional state after failback
          paloaltonetworks.panos.panos_op:
            provider:
              ip_address: "{{ hostvars[current_active_host].ip_address }}"
              username: "{{ hostvars[current_active_host].username }}"
              password: "{{ hostvars[current_active_host].password }}"
            cmd: "request high-availability state functional"
          when:
            - current_active_host is defined
            - current_active_host | length > 0
            - current_active_host != original_active

    - name: Wait for original active role to return
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["ha"]
      register: final_active_state
      until: (final_active_state.ansible_facts.ansible_net_ha_localstate | lower) == 'active'
      retries: 40
      delay: 30
      when: is_initial_active

    - name: Wait for original passive role to return
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["ha"]
      register: final_passive_state
      until: (final_passive_state.ansible_facts.ansible_net_ha_localstate | lower) == 'passive'
      retries: 40
      delay: 30
      when: is_initial_passive



    - name: Re-validate HA1 control channel after upgrade
      paloaltonetworks.panos.panos_active_in_ha:
        provider:
          ip_address: "{{ hostvars[item].ip_address }}"
          username: "{{ hostvars[item].username }}"
          password: "{{ hostvars[item].password }}"
      register: ha_upgrade_assurance_post
      loop: "{{ ansible_play_hosts_all }}"
      loop_control:
        label: "{{ item }}"

    - name: Enforce post-upgrade HA1 status across HA pair
      run_once: true
      delegate_to: localhost
      delegate_facts: true
      vars:
        ha1_checks_post: "{{ ha_upgrade_assurance_post.results | map(attribute='response') | map('default', {}) | list }}"
      block:
        - name: Assert exactly one active and one passive after upgrade
          ansible.builtin.assert:
            that:
              - ha1_checks_post | length == 2
              - (ha1_checks_post | map(attribute='active') | select('equalto', true) | list | length) == 1
              - (ha1_checks_post | map(attribute='active') | select('equalto', false) | list | length) == 1
            fail_msg: "Post-upgrade HA1 check failed; expected one active and one passive. Received {{ ha1_checks_post }}."
        - name: Persist HA1 post-check snapshot
          ansible.builtin.set_fact:
            ha1_upgrade_assurance_post_snapshot: "{{ ha1_checks_post }}"

    - name: Gather HA wiring after upgrade
      paloaltonetworks.panos.panos_facts:
        provider: "{{ device }}"
        gather_subset: ["config"]
      register: ha_cfg_post

    - name: Extract HA section after upgrade
      ansible.builtin.set_fact:
        ha_section_post: "{{ ha_cfg_post.ansible_facts.ansible_net_config | regex_search('(?s)<high-availability>.*?</high-availability>') | default('') }}"

    - name: Record HA wiring after upgrade
      ansible.builtin.set_fact:
        ha1_ip_address_post: >-
          {{ (ha_section_post
              | regex_findall('<ip-address>([^<]+)</ip-address>')
              | default([''], true))
             | first }}
        ha1_netmask_post: >-
          {{ (ha_section_post
              | regex_findall('<netmask>([^<]+)<')
              | default([''], true))
             | first }}
        ha1_port_post: >-
          {{ (ha_section_post
              | regex_findall('<port>([^<]+)</port>')
              | default([''], true))
             | first }}
        ha_peer_ip_post: >-
          {{ (ha_section_post
              | regex_findall('<peer-ip>([^<]+)</peer-ip>')
              | default([''], true))
             | first }}

    - name: Assert HA wiring unchanged after upgrade
      run_once: true
      delegate_to: localhost
      vars:
        hosts: "{{ ansible_play_hosts_all }}"
      block:
        - name: Validate HA1 parameters match pre-upgrade discovery
          ansible.builtin.assert:
            that:
              - hostvars[item].ha1_ip_address_post | default('') == hostvars[item].ha1_ip_address | default('')
              - hostvars[item].ha1_netmask_post | default('') == hostvars[item].ha1_netmask | default('')
              - hostvars[item].ha1_port_post | default('') == hostvars[item].ha1_port | default('')
              - hostvars[item].ha_peer_ip_post | default('') == hostvars[item].ha_peer_ip | default('')
            fail_msg: "HA wiring drift detected post-upgrade on {{ item }}."
          loop: "{{ hosts }}"
          loop_control:
            label: "{{ item }}"

    - name: Run post-upgrade HA readiness checks
      paloaltonetworks.panos.panos_readiness_checks:
        provider:
          ip_address: "{{ hostvars[item].ip_address }}"
          username: "{{ hostvars[item].username }}"
          password: "{{ hostvars[item].password }}"
        checks:
          - ha
        force_fail: true
      register: ha_readiness_post
      loop: "{{ ansible_play_hosts_all }}"
      loop_control:
        label: "{{ item }}"

    - name: Query antivirus package after upgrade
      paloaltonetworks.panos.panos_op:
        provider:
          ip_address: "{{ hostvars[item].ip_address }}"
          username: "{{ hostvars[item].username }}"
          password: "{{ hostvars[item].password }}"
        cmd: "<request><anti-virus><upgrade><info></info></upgrade></anti-virus></request>"
        cmd_is_xml: true
      register: antivirus_info_post
      loop: "{{ ansible_play_hosts_all }}"
      loop_control:
        label: "{{ item }}"

    - name: Cache post-upgrade antivirus version
      ansible.builtin.set_fact:
        ha_antivirus_version_post: >-
          {{ (antivirus_info_post.results[loop.index0].stdout_xml | default(''))
              | regex_findall('(?s)<entry>.*?<version>([^<]+)</version>.*?<current>yes</current>.*?</entry>')
              | first | default('unknown') }}
      loop: "{{ ansible_play_hosts_all }}"
      loop_control:
        label: "{{ item }}"

    - name: Verify antivirus versions match across HA peers after upgrade
      run_once: true
      delegate_to: localhost
      vars:
        antivirus_versions_post: "{{ ansible_play_hosts_all | map('extract', hostvars, 'ha_antivirus_version_post') | list }}"
      ansible.builtin.assert:
        that:
          - antivirus_versions_post | reject('equalto', 'unknown') | list | length == antivirus_versions_post | length
          - (antivirus_versions_post | unique | length) == 1
        fail_msg: "Post-upgrade antivirus mismatch detected across HA peers: {{ antivirus_versions_post }}."

    - name: Report HA upgrade result
      run_once: true
      ansible.builtin.debug:
        msg: |
          HA upgrade complete. Original active host ({{ hostvars['localhost'].ha_active_host }}) is active again and
          original passive host ({{ hostvars['localhost'].ha_passive_host }}) returned to passive. Backups saved under {{ backup_directory }}.
